>>> search by size range
public enum SizeConverterType
{
    LowerBound,
    UpperBound
}
public enum SizeType
{
    Bytes,
    KiloBytes,
    MegaBytes,
    GigaBytes,
    TeraBytes,
    PetaBytes
}
private long SizeConverter(double size, SizeType type, SizeConverterType converterType)
{
    try
    {
        double result = 0;
        int power = 0;
        switch (type)
        {
            case SizeType.Bytes:
                power = 0;
                break;
            case SizeType.KiloBytes:
                power = 1;
                break;
            case SizeType.MegaBytes:
                power = 2;
                break;
            case SizeType.GigaBytes:
                power = 3;
                break;
            case SizeType.TeraBytes:
                power = 4;
                break;
            case SizeType.PetaBytes:
                power = 5;
                break;
        }

        switch (converterType)
        {
            case SizeConverterType.LowerBound:
                result = Math.Floor(((size - 1) * Math.Pow(1024, power)));
                break;
            case SizeConverterType.UpperBound:
                result = Math.Ceiling(((size + 1) * Math.Pow(1024, power)));
                break;
        }
        if (result >= (double)long.MaxValue)
            return -1;
        return Convert.ToInt64(result);
    }
    catch{ return -1; }
}
private bool MatchBySize(FileInfo fileInfo, double size, SizeType sizeType)
{
    long lowerBound = SizeConverter(size, sizeType,SizeConverterType.LowerBound);

    if (lowerBound < 0)
        return false;

    long upperBound = SizeConverter(size, sizeType, SizeConverterType.UpperBound);

    if (upperBound < 0)
        return false;

    return (fileInfo.Length >= lowerBound && fileInfo.Length <= upperBound);
}

private bool MatchBySizeRange(FileInfo fileInfo, double lowerBoundSize, double upperBoundSize, SizeType sizeType)
{
    if (lowerBoundSize < 0)
        return false;
    if (upperBoundSize < 0)
        return false;
    if (lowerBoundSize >= upperBoundSize)
        return false;
    long lowerBound = SizeConverter(lowerBoundSize, sizeType, SizeConverterType.LowerBound);
    if (lowerBound < 0)
        return false;
    long upperBound = SizeConverter(upperBoundSize, sizeType, SizeConverterType.UpperBound);
    if (upperBound < 0)
        return false;
    return (fileInfo.Length >= lowerBound && fileInfo.Length <= upperBound);
}

public enum DateComparisonType
{
    CreationDate,
    LastModificationDate,
    LastAccessDate
}
private bool MatchByDate(FileInfo fileInfo, DateTime dateTime, DateComparisonType comparisonType)
{
    DateTime fileInfoDate = new DateTime();
    switch(comparisonType)
    {
        case DateComparisonType.CreationDate:
            fileInfoDate = fileInfo.CreationTime.Date;
            break;
        case DateComparisonType.LastModificationDate:
            fileInfoDate = fileInfo.LastWriteTime.Date;
            break;
        case DateComparisonType.LastAccessDate:
            fileInfoDate = fileInfo.LastAccessTime.Date;
            break;
    }
    return DateTime.Equals(fileInfoDate.Date, dateTime.Date);
}

private bool MatchByDateRange(FileInfo fileInfo, DateTime lowerBoundDate, DateTime upperBoundDate, DateComparisonType comparisonType)
{
    DateTime fileInfoDate = new DateTime();
    switch (comparisonType)
    {
        case DateComparisonType.CreationDate:
            fileInfoDate = fileInfo.CreationTime.Date;
            break;
        case DateComparisonType.LastModificationDate:
            fileInfoDate = fileInfo.LastWriteTime.Date;
            break;
        case DateComparisonType.LastAccessDate:
            fileInfoDate = fileInfo.LastAccessTime.Date;
            break;
    }
    return (fileInfoDate >= lowerBoundDate && fileInfoDate <= upperBoundDate);
}

private bool MatchByPattern(FileInfo fileInfo, string pattern)
{
    bool result = false;
    try
    {
        result = Regex.IsMatch(Path.GetFileNameWithoutExtension(fileInfo.Name), pattern, RegexOptions.Compiled);
    }
    catch { result = false; }
    return result;
}

private bool MatchByPatternWithExtension(FileInfo fileInfo, string pattern)
{
    bool result = false;
    try
    {
        result = Regex.IsMatch(fileInfo.Name, pattern, RegexOptions.Compiled);
    }
    catch { result = false; }
    return result;
}

private bool MatchByExtension(FileInfo fileInfo, string extension)
{
    extension = Regex.Match(extension, @"(\.)?\w+").Value;
    if (!extension.StartsWith("."))
        extension = "." + extension;
    return fileInfo.Extension.Equals(extension, StringComparison.InvariantCultureIgnoreCase);
}
private bool MatchByAttributes(FileInfo fileInfo, FileAttributes fileAttributes)
{
    return fileInfo.Attributes == fileAttributes;
}

private bool MatchByName(FileInfo fileInfo, string keyword, StringComparison stringComparison)
{
    return Path.GetFileNameWithoutExtension(fileInfo.Name).Equals(keyword, stringComparison);
}
private bool MatchByNameWithExtension(FileInfo fileInfo, string keyword, StringComparison stringComparison)
{
    return fileInfo.Name.Equals(keyword, stringComparison);
}

public enum CommonSize
{
    Empty,   // 0 KB
    Tiny,    // 0-10 KB
    Small,   // 10-100 KB
    Medium,  // 100 KB - 1 MB
    Large,   // 1 - 16 MB
    Huge,    // 16 - 128 MB
    Gigantic // > 128 MB 
}
private bool MatchByCommonSize(FileInfo fileInfo, CommonSize commonSize)
{
    switch(commonSize)
    {
        case CommonSize.Empty:
            return fileInfo.Length == 0;
        case CommonSize.Tiny:
            return MatchBySizeRange(fileInfo, 0, 10, SizeType.KiloBytes);
        case CommonSize.Small:
            return MatchBySizeRange(fileInfo, 10, 100, SizeType.KiloBytes);
        case CommonSize.Medium:
            return MatchBySizeRange(fileInfo, 100, 1000, SizeType.KiloBytes);
        case CommonSize.Large:
            return MatchBySizeRange(fileInfo, 1, 16, SizeType.MegaBytes);
        case CommonSize.Huge:
            return MatchBySizeRange(fileInfo, 16, 128, SizeType.MegaBytes);
        default:
            return fileInfo.Length > SizeConverter(129, SizeType.MegaBytes, SizeConverterType.LowerBound);
    }
}





/* ======================== FOR DIRECTORY ========================*/

private bool MatchDirByName(DirectoryInfo directoryInfo, string keyword, StringComparison stringComparison)
{
    return directoryInfo.Name.Equals(keyword, stringComparison);
}
private bool MatchDirByDate(DirectoryInfo directoryInfo, DateTime dateTime)
{
    DateTime dirInfoDate = directoryInfo.CreationTime;
    return DateTime.Equals(dirInfoDate.Date, dateTime.Date);
}
private bool MatchDirByAttributes(DirectoryInfo directoryInfo, FileAttributes fileAttributes)
{
    return directoryInfo.Attributes == fileAttributes;
}
private bool MatchDirByPattern(DirectoryInfo directoryInfo, string pattern)
{
    bool result = false;
    try
    {
        result = Regex.IsMatch(directoryInfo.Name, pattern, RegexOptions.Compiled);
    }
    catch { result = false; }
    return result;
}